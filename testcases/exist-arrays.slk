data int_star {
    int val;
}.

/* possibly empty array segment */
pred aseg<b> ==
    self=b
 or self::aseg_plus<b> & self<b
 inv self<=b.

/* nonempty array segment */
pred aseg_plus<b> ==
    self::int_star<v> & b=self+1
 or (exists v: self::int_star<v> * c::aseg<b> & c=self+1)
 inv self<b.

lemma "focus" self::aseg<self+n> & b=self+k & c=b+1 & Univ(v) <-> self::aseg<b> * b::int_star<v> * c::aseg<self+n>.

/**********************************
 * nonempty ==> possibly empty
 * possibly empty =/=> nonempty
 **********************************/

/*
 * (1)
 */
checkentail a::aseg_plus<_> & c=a+1 |- c::aseg<_>.
print residue.
expect Valid.

/*
 * (2)
 */
checkentail a::aseg<_> |- a::aseg_plus<_>.
print residue.
expect Fail.

/**********************************
 * decompose array into elements
 **********************************/

/*
 * (3) int a[1] = {z};
 */
checkentail a::aseg<a+1> |- a::int_star<z>.
print residue.
expect Valid.

/*
 * (4) int a[2] = {z,y};
 */
checkentail a::aseg<a+2> & b=a+1 |- a::int_star<z> * b::int_star<y>.
print residue.
expect Valid.

/*
 * (5) int a[3] = {z,y,x};
 */
checkentail a::aseg<a+3> & b=a+1 & c=b+1 |- a::int_star<z> * b::int_star<y> * c::int_star<x>.
print residue.
expect Valid.

/**********************************
 * compose elements into array
 **********************************/

/*
 * (6) int a[1] = {z};
 */
checkentail a::int_star<z> |- a::aseg<a+1>.
print residue.
expect Valid.

/*
 * (7) int a[2] = {z,y};
 */
checkentail a::int_star<z> * b::int_star<y> & b=a+1 |- a::aseg<a+2>.
print residue.
expect Valid.

/*
 * (8) int a[3] = {z,y,x};
 */
checkentail a::int_star<z> * b::int_star<y> * c::int_star<x> & b=a+1 & c=b+1 |- a::aseg<a+3>.
print residue.
expect Valid.

/**********************************
 * focus on one element of array
 **********************************/

/*
 * (9) int a[1] = {v};
 */
checkentail a::aseg<a+1> & b=a+1 |- a::int_star<v> * b::aseg<a+1>.
print residue.
expect Valid.

/*
 * (10) int a[2] = {v,_};
 */
checkentail a::aseg<a+2> & b=a+1 |- a::int_star<v> * b::aseg<a+2>.
print residue.
expect Valid.

/*
 * (11) int a[2] = {_,v};
 */
checkentail a::aseg<a+2> & b=a+1 |- a::aseg<b> * b::int_star<v>.
print residue.
expect Valid.

/*
 * (12) int a[3] = {v,_,_};
 */
checkentail a::aseg<a+3> & b=a+1 |- a::int_star<v> * b::aseg<a+3>.
print residue.
expect Valid.

/*
 * (13) int a[3] = {_,v,_};
 */
checkentail a::aseg<a+3> & b=a+1 & c=b+1 |- a::aseg<b> * b::int_star<v> * c::aseg<a+3>.
print residue.
expect Valid.

/*
 * (14) int a[3] = {_,_,v};
 */
checkentail a::aseg<a+3> & b=a+2 |- a::aseg<b> * b::int_star<v>.
print residue.
expect Valid.

/*
 * (15) int a[4] = {v,_,_,_};
 */
checkentail a::aseg<a+4> & b=a+1 |- a::int_star<v> * b::aseg<a+4>.
print residue.
expect Valid.

/*
 * (16) int a[4] = {_,v,_,_};
 */
checkentail a::aseg<a+4> & b=a+1 & c=b+1 |- a::aseg<b> * b::int_star<v> * c::aseg<a+4>.
print residue.
expect Valid.

/*
 * (17) int a[4] = {_,_,v,_};
 */
checkentail a::aseg<a+4> & b=a+2 & c=b+1 |- a::aseg<b> * b::int_star<v> * c::aseg<a+4>.
print residue.
expect Valid.

/*
 * (18) int a[4] = {_,_,_,v};
 */
checkentail a::aseg<a+4> & b=a+3 |- a::aseg<b> * b::int_star<v>.
print residue.
expect Valid.

/**********************************
 * existentials over points-to content
 **********************************/

/*
 * (19)
 */
//checkentail a::aseg<b> & b=a+1 |- exists v: a::int_star<v> & v>0. // v>0 is unprovable.
checkentail a::aseg<b> & b=a+1 |- exists v: a::int_star<v>.
print residue.
expect Valid.

/**********************************
 * existentials over array pointers
 **********************************/

/*
 * (20)
 */
//checkentail x::aseg_plus<c> & x=1 & c>=8 |- exists b: x::aseg_plus<b> * b::aseg<c> & 6<=b<=8. // Unification error: b is both an int_star and a NUM.
checkentail x::aseg_plus<c> |- x::aseg_plus<b> * b::aseg<c>.
print residue.
expect Valid.

/**********************************
 * universals over points-to content
 **********************************/

/*
 * (21)
 */
checkentail r::int_star<c> |- r::int_star<42>.
print residue.
expect Fail.

/*
 * (22)
 */
checkentail r::int_star<c> & Univ(c) |- r::int_star<42>.
print residue.
expect Valid.

/*
 * (23)
 * requires-ensures entailment of method `foo(int* a)`
 * only provable after existentially instantiating r,c.
 * a method call will bind and existentially instantiate r,c.
 */
checkentail a::aseg<r> * r::int_star<c> * x::aseg<a+10> & x=r+1 & 6<=r-a<=8 & Univ(c) |- a::aseg<r> * r::int_star<42> * x::aseg<a+10> & x=r+1.
print residue.
expect Valid.

/**********************************
 * universals over array pointers
 * motivating example: `foo(int* a)` may be called under any program state `a::aseg_plus<a+10>`.
 **********************************/

/*
 * (24)
 */
checkentail r::int_star<c> |- s::int_star<c>.
print residue.
expect Fail.

/*
 * (25)
 */
checkentail r::int_star<c> & Univ_star(r) |- s::int_star<c>.
print residue.
expect Valid.

/*
 * (26) case-split of program state `a::aseg_plus<a+10>`: case r>a+10
 */
//checkentail r>a+10 |- 6<=r-a<=8. // Fail.(must)
checkentail a::aseg_plus<a+10> & r>a+10 |- a::aseg_plus<r> * r::int_star<c> * x::aseg<a+10> & x=r+1 & 6<=r-a<=8. // Fail.(may)
print residue.
expect Fail.

/*
 * (27) pure part of case-split of program state `a::aseg_plus<a+10>`: case r<=a+10
 */
checkentail a<r<=a+10 |- 6<=r-a<=8.
print residue.
expect Fail.

/*
 * (28) pure part + Univ of case-split of program state `a::aseg_plus<a+10>`: case r<=a+10
 */
checkentail a<r<=a+10 & Univ(r) |- 6<=r-a<=8.
print residue.
expect Valid.

/*
 * (29) part of case-split of program state `a::aseg_plus<a+10>`: case r<=a+10
 */
checkentail r::aseg_plus<_> & a<r<=a+10 |- r::int_star<_> & 6<=r-a<=8.
print residue.
expect Fail.

/*
 * (30) part of + Univ case-split of program state `a::aseg_plus<a+10>`: case r<=a+10
 */
checkentail r::aseg_plus<_> & a<r<=a+10 & Univ_star(r) |- r::int_star<_> & 6<=r-a<=8.
print residue.
expect Valid.

/*
 * (31) case-split of program state `a::aseg_plus<a+10>`: case r<=a+10
 */
checkentail a::aseg_plus<r> * r::aseg<a+10> & r<=a+10 & Univ_star(r) |- a::aseg_plus<r> * r::int_star<c> * x::aseg<a+10> & x=r+1 & a<r & 6<=r-a<=8.
print residue.
expect Valid.
